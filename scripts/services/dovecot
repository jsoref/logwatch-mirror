########################################################
# $Id: dovecot,v 1.18 2010/09/18 17:41:00 stefan Exp $
########################################################
# $Log: dovecot,v $
# Revision 1.18  2010/09/18 17:41:00  stefan
# ignore: ssl-build-param
#
# Revision 1.17  2009/06/02 14:48:06  mike
# Removed some periods that were in the Fedora patch and broke the file -mgt
#
# Revision 1.16  2009/06/02 14:45:48  mike
# Patch from Fedora (Ivana Hutarova Varekova) -mgt
#
# Revision 1.15  2008/11/18 06:02:49  mike
# Rolled back..that was wrong. -mgt
#
# Revision 1.14  2008/11/18 06:00:34  mike
# Removed a space should be better -mgt
#
# Revision 1.13  2008/11/18 04:32:49  mike
# Added bytes detected to IMAP disconnect match expect more issues -mgt
#
# Revision 1.12  2008/08/11 15:38:02  mike
# Connection closed patch from Niels Baggesen -mgt
#
# Revision 1.11  2008/06/30 23:07:51  kirk
# fixed copyright holders for files where I know who they should be
#
# Revision 1.10  2008/03/24 23:31:26  kirk
# added copyright/license notice to each script
#
# Revision 1.9  2008/02/14 18:19:51  mike
# Patch from Gilles Detillieux summarize pop3/imap -mgt
#
# Revision 1.8  2008/01/16 20:11:04  bjorn
# Filtering dovecot start-up message, by Gilles Detillieux.
#
# Revision 1.7  2007/06/18 03:54:45  bjorn
# Better printing of IPv6 addresses, by Patrick Vande Walle.
#
# Revision 1.6  2007/03/17 19:13:13  bjorn
# Now handling dovecot starts/kills.
#
# Revision 1.5  2006/12/20 15:25:09  bjorn
# Additional filtering, by Ivana Varekova.
#
# Revision 1.4  2006/08/13 22:02:31  bjorn
# IPv4 addresses displayed in native format, and don't display user totals
# if user connects from only one IP address; changes by Patrick Vande Walle.
#
# Revision 1.3  2006/08/13 21:06:33  bjorn
# Added support for Dovecot 1.0 based on patches from Mark Nienberg, and
# IP addresses displayed without brackets for consistency across versions;
# modifications by Patrick Vande Walle.
#
# Revision 1.2  2005/12/07 04:31:44  bjorn
# Added $dovecot_ignore_host.
#
# Revision 1.1  2005/09/18 17:01:05  bjorn
# Dovecot filters written by Patrick Vande Walle.
#
########################################################
# Please send all comments, suggestions, bug reports,
#    etc, to logwatch-devel@lists.sourceforge.net
########################################################
# The Dovecot script was written by:
#   Patrick Vande Walle <patrick@isoc.lu>
# Based on previous work by
#    Pawel Golaszewski <blues@gda.pl>
#
# TODO:
# - use printf features to align text in table
#
########################################################

########################################################
## Copyright (c) 2008 Patrick Vande Walle
## Covered under the included MIT/X-Consortium License:
##    http://www.opensource.org/licenses/mit-license.php
## All modifications and contributions by other persons to
## this script are assumed to have been donated to the
## Logwatch project and thus assume the above copyright
## and licensing terms.  If you want to make contributions
## under your own copyright or a different license this
## must be explicitly stated in the contribution an the
## Logwatch project reserves the right to not accept such
## contributions.  If you have made significant
## contributions to this script and want to claim
## copyright please contact logwatch-devel@lists.sourceforge.net.
#########################################################

my $Debug = $ENV{'LOGWATCH_DEBUG'} || 0;
my $Detail = $ENV{'LOGWATCH_DETAIL_LEVEL'} || 0;
my $IgnoreHost = $ENV{'dovecot_ignore_host'} || "";

my $Restarts = 0;
my $End = 0;

if ( $Debug >= 5 ) {
    print STDERR "\n\nDEBUG \n\n";
}

while (defined($ThisLine = <STDIN>)) {
     # remove timestamp.  We can't use *RemoveHeaders because we need the
     # service name
     $ThisLine =~ s/^\w{3} .\d \d\d:\d\d:\d\d [^ ]* //;
     if (
       ($ThisLine =~ /ssl-build-param: SSL parameters regeneration completed/) or
       ($ThisLine =~ /deliver.*/) or
       ($ThisLine =~ /auth-worker/) or
       ($ThisLine =~ /IMAP.* failed with mbox file/)
) {
        # We don't care about these
     } elsif ( $ThisLine =~ /Killed with signal /) {
         $End++;
     } elsif ( $ThisLine =~ /Dovecot (v\d[^ ]* |)starting up$/) {
         $Restarts++;
         $End = 0;
     } elsif ( ($User, $Host) = ( $ThisLine =~ /^pop3-login: Login: (.*?) \[(.*)\]/ ) ) {
      if ($Host !~ /$IgnoreHost/) {
         $Login{$User}{$Host}++;
         $LoginPOP3{$User}++;
         $ConnectionPOP3{$Host}++;
         $Connection{$Host}++;
      }
   } elsif ( ($User, $Host) = ( $ThisLine =~ /^imap-login: Login: (.*?) \[(.*)\]/ ) ) {
      if ($Host !~ /$IgnoreHost/) {
         $Login{$User}{$Host}++;
         $LoginIMAP{$User}++;
         $ConnectionIMAP{$Host}++;
         $Connection{$Host}++;
      }
    } elsif ( ($User, $Mailbox) = ( $ThisLine =~ /^dovecot: deliver\((.*)\): msgid=.*: saved mail to (\S+)/ ) ) {
      $Deliver{$User}{$Mailbox}++;

# This is for Dovecot 1.0 series
    } elsif ( ($User, $Host) = ( $ThisLine =~ /^dovecot: pop3-login: Login: user=\<(.*?)\>.*rip=(.*)\, lip=/ ) ) {
      if ($Host !~ /$IgnoreHost/) {
         $Login{$User}{$Host}++;
         $LoginPOP3{$User}++;
         $ConnectionPOP3{$Host}++;
         $Connection{$Host}++;
      }
   } elsif ( ($User, $Host) = ( $ThisLine =~ /^dovecot: imap-login: Login: user=\<(.*?)\>.*rip=(.*)\, lip=/) ) {
      if ($Host !~ /$IgnoreHost/) {
         $Login{$User}{$Host}++;
         $LoginIMAP{$User}++;
         $ConnectionIMAP{$Host}++;
         $Connection{$Host}++;
       }

   } elsif ($ThisLine =~ /Disconnected \[/) {
      $Disconnected{"no reason"}++;
   } elsif (($Reason) = ($ThisLine =~ /Disconnected: (.*) \[/) ) {
      $Disconnected{$Reason}++;
   } elsif (($Reason) = ($ThisLine =~ /Disconnected \((.*)\):/) ) {
      $Disconnected{$Reason}++;
   } elsif (($Reason, $Host) = ($ThisLine =~ /TLS initialization failed/) ) {
      $TLSInitFail++;
   } elsif (($Host) = ($ThisLine =~ /Aborted login \[(.*)\]/) ) {
      $Aborted{$Host}++;
   } elsif (($Reason) = ($ThisLine =~ /Aborted login \((.*)\):/)) {
      $Aborted{$Reason}++;

# This is for Dovecot 1.0 series
# Overly general matches in this section -mgt

   } elsif ($ThisLine =~ /Disconnected for inactivity/) {
      $Disconnected{"Inactivity"}++;
   } elsif ($ThisLine =~ /Disconnected in IDLE/) {
      $Disconnected{"in IDLE"}++;
   } elsif (($ThisLine =~ /Disconnected$/) or
            (($Reason) = ($ThisLine =~ /pop3-login: Disconnected: (.+)/)) or
            (($Reason) = ($ThisLine =~ /imap-login: Disconnected: (.+)/)) ) {
      $Disconnected{"no reason"}++;
   } elsif ( (($Reason) = ($ThisLine =~ /POP3.+: Disconnected: (.+) top/)) or
          (($Reason) = ($ThisLine =~ /pop3-login: Disconnected \((.+)\): /)) or
          (($Reason) = ($ThisLine =~ /IMAP.+: Disconnected: (.+) bytes=/)) or
          (($Reason) = ($ThisLine =~ /IMAP.+: Disconnected: (.+)/)) ) {
      $Disconnected{$Reason}++;
   } elsif ($ThisLine =~ /(IMAP|POP3).+: (Connection closed.*)/) {
      $Disconnected{$2}++;
   } elsif (($Reason) = ($ThisLine =~ /IMAP.+: Connection closed bytes=/))  {
        $ConnectionCl{"no reason"}++;
   } elsif ( (($Reason) = ($ThisLine =~ /IMAP.+: Connection closed: (.*) bytes=/)) or
             (($Reason) = ($ThisLine =~ /POP3.+: Connection closed: (.*) (top=|bytes=)/)) ) {
      $ConnectionCl{$Reason}++;
   } elsif ($ThisLine =~ /POP3.+: Connection closed top=.* retr=.* del=.* size=.*/) {
      $ConnectionCl{"no reason"}++;
   } elsif (($Error) = ($ThisLine =~ /child \d* \(login\) returned error (.*)/)) {
   # dovecot: child 23747 (login) returned error 89
      $ChildErr{$Error}++;
   } elsif (($Name) = ($ThisLine =~ /dovecot: IMAP\((.*)\): .*(.*) failed: Disk quota exceeded/)) {
   # dovecot: IMAP(podracka): mkdir(/home/LF/KLINIKY/podracka/mail/.imap/saved-messages) failed: Disk quota exceeded
      $DiskQuotaExceed{$Name}++;
   } else {
      # Report any unmatched entries...
      chomp($ThisLine);
      $OtherList{$ThisLine}++;
   }
}

################################################

if ( $End ) {
   print "\nDovecot was killed, and not restarted afterwards.\n";
}

if ( ( $Detail >=5 ) and $Restarts ) {
   print "\nDovecot restarted $Restarts time(s).";
}

if ( ( $Detail >= 5 ) and (keys %Connection)) {
   print     "\n[Dovecot IMAP and POP3] Connections:".
             "\n====================================".
             "\n                                  Host |    POP3   |   IMAP   |   Total ".
             "\n-------------------------------------- | --------- |--------- | ---------";

   $TLSInitFail = 0;
   foreach $Host (sort keys %Connection) {
      $Total = $Connection{$Host};
      if (defined ($ConnectionPOP3{$Host})) {
         $Conns = $ConnectionPOP3{$Host};
      } else {
         $Conns = 0;
      }
      if (defined ($ConnectionIMAP{$Host})) {
         $IMAP = $ConnectionIMAP{$Host};
      } else {
         $IMAP = 0;
      }
# Cleanly display IPv4 addresses
      $Host=~ s/::ffff://;
      $HostLength = length($Host);
      $HostSpaceLength = 38 - $HostLength;
      $CountLength = length("$Conns");
      $CountSpaceLength = 10 - $CountLength;
      $IMAPLength = length("$IMAP");
      $IMAPSpaceLength = 9 - $IMAPLength;
      $TotalLenght = length("$Total");
      $TotalSpaceLength = 10 - $TotalLenght;
      print "\n" ." " x $HostSpaceLength . $Host . " |" . " " x $CountSpaceLength .  $Conns .
            " |" . " " x $IMAPSpaceLength . $IMAP . " |" . " " x $TotalSpaceLength . $Total;
      $POP3Count += $Conns;
      $IMAPCount += $IMAP;
      $TotalCount += $Total;
   }
   $POP3Length = length("$POP3Count");
   $POP3SpaceLength = 50 - $POP3Length;
   $IMAPLength = length("$IMAPCount");
   $IMAPSpaceLength = 9 - $IMAPLength;
   $TotalLength = length("$TotalCount");
   $totalSpaceLength = 10 - $TotalLength;
   print "\n" . "-" x 73;
   print "\n" . " " x $POP3SpaceLength . $POP3Count . " |" . " " x $IMAPSpaceLength . $IMAPCount .
                 " |" . " " x $totalSpaceLength . $TotalCount . "\n";
}

if ( ( $Detail >= 10 ) and (keys %Deliver)) {
   print "\n\nDovecot Deliveries:";
   $DeliverCount = 0;
   foreach my $User (keys %Deliver) {
      print "\n\n  User $User:";
      $UserCount = 0;
      $NumMailboxes = 0;
      foreach $Mailbox (keys %{$Deliver{$User}}) {
         $NumMailboxes++;
         $MailboxCount = $Deliver{$User}{$Mailbox};
         print "\n    To $Mailbox: $MailboxCount Time(s)";
         $UserCount += $MailboxCount;
      }
      $DeliverCount += $UserCount;
      if ($NumMailboxes > 1) {
      print "\n  Total: $UserCount Time(s)";
      }
   }
   print "\n\nTotal: $DeliverCount successful deliveries";
}

if ( ( $Detail >= 10 ) and (keys %Login)) {
   print "\n\nDovecot IMAP and POP3 Successful Logins:";
   $LoginCount = 0;
   foreach my $User (keys %Login) {
      print "\n\n  User $User:";
      if ($LoginPOP3{$User} > 0 || $LoginIMAP{$User} > 0) {
         print "   (";
         if ($LoginPOP3{$User} > 0) { print "$LoginPOP3{$User} POP3"; };
         if ($LoginPOP3{$User} > 0 && $LoginIMAP{$User} > 0) { print "/"; };
         if ($LoginIMAP{$User} > 0) { print "$LoginIMAP{$User} IMAP"; };
         print ")";
      }
      $UserCount = 0;
      $NumHosts = 0;
      foreach $Host (keys %{$Login{$User}}) {
         $NumHosts++;
         $HostCount = $Login{$User}{$Host};
# Cleanly display IPv4 addresses
         $Host=~ s/::ffff://;
         print "\n    From $Host: $HostCount Time(s)";
         $UserCount += $HostCount;
      }
      $LoginCount += $UserCount;
      if ($NumHosts > 1) {
      print "\n  Total: $UserCount Time(s)";
      }
   }
   print "\n\nTotal: $LoginCount successful logins";
}

if (keys %Disconnected) {
   print "\n\nDovecot disconnects:";
   foreach my $Reason (sort keys %Disconnected) {
      print "\n   $Reason: $Disconnected{$Reason} Time(s)";
   }
}

if (keys %ConnectionCl) {
   print "\n\nDovecot connections closed:";
   foreach my $Reason (sort keys %ConnectionCl) {
      print "\n   $Reason: $ConnectionCl{$Reason} Time(s)";
   }
}

if (keys %ChildErr) {
   print "\n\nDovecot child error:";
   foreach my $Error (sort keys %ChildErr) {
      print "\n   error number ". $Error . ": ". $ChildErr{$Error} ." Time(s)";
   }
}

if ((keys %Aborted) && ($Detail >= 10)) {
   print "\n\nLogout/aborts:";
   foreach my $Host (sort keys %Aborted) {
      print "\n   $Host: $Aborted{$Host} Time(s)";
   }
}

if ($TLSInitFail > 0) {
   print "\n\nTLS Initialization failed $TLSInitFail Time(s)";
}

if (keys %DiskQuotaExceed) {
   print "\n\nDisk quota exceeded:";
   foreach my $Name (sort keys %DiskQuotaExceed) {
      print "\n   disk quota for user '". $Name . "' exceeded: ". $DiskQuotaExceed{$Name} ." Time(s)";
   }
}

if (keys %OtherList) {
   print "\n\n**Unmatched Entries**\n";
   foreach $line (sort {$a cmp $b} keys %OtherList) {
      print "   $line: $OtherList{$line} Time(s)\n";
   }
}

exit(0);


# vi: shiftwidth=3 tabstop=3 syntax=perl et
# Local Variables:
# mode: perl
# perl-indent-level: 3
# indent-tabs-mode: nil
# End:
